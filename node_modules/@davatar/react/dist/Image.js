"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const contracts_1 = require("@ethersproject/contracts");
const bn_js_1 = __importDefault(require("bn.js"));
const react_1 = __importStar(require("react"));
const AvatarProvider_1 = require("./AvatarProvider");
const Blockies_1 = __importDefault(require("./Blockies"));
const Jazzicon_1 = __importDefault(require("./Jazzicon"));
const cache_1 = require("./cache");
const resolve_1 = require("./resolve");
const erc721Abi = [
    'function ownerOf(uint256 tokenId) view returns (address)',
    'function tokenURI(uint256 _tokenId) external view returns (string)',
];
const erc1155Abi = [
    'function balanceOf(address _owner, uint256 _id) view returns (uint256)',
    'function uri(uint256 _id) view returns (string)',
];
function Image({ uri, style, className, size, address, provider, generatedAvatarType, defaultComponent, cacheTTL, }) {
    const [url, setUrl] = (0, react_1.useState)(null);
    const [loaded, setLoaded] = (0, react_1.useState)(false);
    const avatarEthersProvider = (0, AvatarProvider_1.useAvatarEthersProvider)(provider);
    const ethersProvider = avatarEthersProvider;
    (0, react_1.useEffect)(() => {
        if (!uri && address) {
            const cachedUrl = (0, cache_1.getCachedUrl)(address.toLowerCase());
            if (cachedUrl) {
                setUrl(cachedUrl);
            }
        }
        if (!uri) {
            return;
        }
        if (uri) {
            const cachedUrl = (0, cache_1.getCachedUrl)(uri);
            if (cachedUrl) {
                setUrl(cachedUrl);
                return;
            }
        }
        if (uri && address) {
            const cachedUrl = (0, cache_1.getCachedUrl)(`${address.toLowerCase()}/${uri}`);
            if (cachedUrl) {
                setUrl(cachedUrl);
                return;
            }
        }
        const match = new RegExp(/([a-z]+):\/\/(.*)/).exec(uri);
        const match721 = new RegExp(/eip155:1\/erc721:(\w+)\/(\w+)/).exec(uri);
        const match1155 = new RegExp(/eip155:1\/erc1155:(\w+)\/(\w+)/).exec(uri);
        if (match && match.length === 3) {
            const protocol = match[1];
            const id = match[2];
            switch (protocol) {
                case 'ar': {
                    const baseUrl = 'https://arweave.net';
                    fetch(`${baseUrl}/graphql`, {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json;charset=UTF-8',
                        },
                        body: JSON.stringify({
                            query: `
              {
                transactions(ids: ["${id}"]) {
                  edges {
                    node {
                      id
                      owner {
                        address
                      }
                    }
                  }
                }
              }
              `,
                        }),
                    })
                        .then(d => d.json())
                        .then(res => res.data.transactions.edges[0].node)
                        .then(tx => fetch(`${baseUrl}/graphql`, {
                        method: 'POST',
                        headers: {
                            'content-type': 'application/json;charset=UTF-8',
                        },
                        body: JSON.stringify({
                            query: `
                {
                  transactions(owners: ["${tx.owner.address}"], tags: { name: "Origin", values: ["${tx.id}"] }, sort: HEIGHT_DESC) {
                    edges {
                      node {
                        id
                      }
                    }
                  }
                }
                `,
                        }),
                    }))
                        .then(res => res.json())
                        .then(res => {
                        if (res.data && res.data.transactions.edges.length > 0) {
                            setUrl(`${baseUrl}/${res.data.transactions.edges[0].node.id}`);
                        }
                        else {
                            setUrl(`${baseUrl}/${id}`);
                        }
                    })
                        .catch(e => console.error(e)); // eslint-disable-line
                    break;
                }
                case 'ipfs':
                    setUrl(`https://gateway.ipfs.io/ipfs/${id}`);
                    break;
                case 'ipns':
                    setUrl(`https://gateway.ipfs.io/ipns/${id}`);
                    break;
                case 'http':
                case 'https':
                    setUrl(uri);
                    break;
                default:
                    setUrl(uri);
                    break;
            }
        }
        else if (match721 && match721.length === 3) {
            const contractId = match721[1].toLowerCase();
            const tokenId = match721[2];
            const normalizedAddress = address === null || address === void 0 ? void 0 : address.toLowerCase();
            const erc721Contract = new contracts_1.Contract(contractId, erc721Abi, ethersProvider);
            (() => __awaiter(this, void 0, void 0, function* () {
                if (normalizedAddress) {
                    const owner = yield erc721Contract.ownerOf(tokenId);
                    if (!owner || owner.toLowerCase() !== normalizedAddress) {
                        throw new Error('ERC721 token not owned by address');
                    }
                }
                const tokenURI = yield erc721Contract.tokenURI(tokenId);
                const res = yield fetch((0, resolve_1.getGatewayUrl)(tokenURI, new bn_js_1.default(tokenId).toString(16)));
                const data = (yield res.json());
                setUrl((0, resolve_1.getGatewayUrl)(data.image));
            }))();
        }
        else if (match1155 && match1155.length === 3) {
            const contractId = match1155[1].toLowerCase();
            const tokenId = match1155[2];
            const erc1155Contract = new contracts_1.Contract(contractId, erc1155Abi, ethersProvider);
            (() => __awaiter(this, void 0, void 0, function* () {
                if (address) {
                    const balance = yield erc1155Contract.balanceOf(address, tokenId);
                    if (balance.isZero()) {
                        throw new Error('ERC1155 token not owned by address');
                    }
                }
                const tokenURI = yield erc1155Contract.uri(tokenId);
                const res = yield fetch((0, resolve_1.getGatewayUrl)(tokenURI, new bn_js_1.default(tokenId).toString(16)));
                const data = (yield res.json());
                setUrl((0, resolve_1.getGatewayUrl)(data.image));
            }))();
        }
        else {
            setUrl((0, resolve_1.getGatewayUrl)(uri));
        }
    }, [uri, address, ethersProvider]);
    const onLoad = (0, react_1.useCallback)(() => {
        setLoaded(true);
        if (address && url) {
            (0, cache_1.storeCachedURI)(address, url, cacheTTL);
        }
    }, [address, url, cacheTTL]);
    let avatarImg = null;
    const cssStyle = Object.assign({ display: loaded ? undefined : 'none', width: `${size}px`, height: `${size}px`, borderRadius: `${size}px` }, (style || {}));
    if (url) {
        avatarImg = react_1.default.createElement("img", { alt: "avatar", style: cssStyle, className: className, src: url, onLoad: onLoad });
    }
    const defaultAvatar = (!url || !loaded) &&
        address &&
        (defaultComponent ||
            (generatedAvatarType === 'blockies' ? (react_1.default.createElement(Blockies_1.default, { address: address, size: size })) : (react_1.default.createElement(Jazzicon_1.default, { address: address, size: size }))));
    return (react_1.default.createElement(react_1.default.Fragment, null,
        defaultAvatar,
        avatarImg));
}
exports.default = Image;
//# sourceMappingURL=Image.js.map